import { BitroundCodec } from "./codecs/bitround.js";
import { BytesCodec } from "./codecs/bytes.js";
import { Crc32cCodec } from "./codecs/crc32c.js";
import { GzipCodec } from "./codecs/gzip.js";
import { JsonCodec } from "./codecs/json2.js";
import { TransposeCodec } from "./codecs/transpose.js";
import { VLenUTF8 } from "./codecs/vlen-utf8.js";
import { ZlibCodec } from "./codecs/zlib.js";
import { assert } from "./util.js";
function create_default_registry() {
    return new Map()
        .set("blosc", () => import("numcodecs/blosc").then((m) => m.default))
        .set("lz4", () => import("numcodecs/lz4").then((m) => m.default))
        .set("zstd", () => import("numcodecs/zstd").then((m) => m.default))
        .set("gzip", () => GzipCodec)
        .set("zlib", () => ZlibCodec)
        .set("transpose", () => TransposeCodec)
        .set("bytes", () => BytesCodec)
        .set("crc32c", () => Crc32cCodec)
        .set("vlen-utf8", () => VLenUTF8)
        .set("json2", () => JsonCodec)
        .set("bitround", () => BitroundCodec);
}
export const registry = create_default_registry();
export function create_codec_pipeline(chunk_metadata) {
    let codecs;
    return {
        async encode(chunk) {
            if (!codecs)
                codecs = await load_codecs(chunk_metadata);
            for (const codec of codecs.array_to_array) {
                chunk = await codec.encode(chunk);
            }
            let bytes = await codecs.array_to_bytes.encode(chunk);
            for (const codec of codecs.bytes_to_bytes) {
                bytes = await codec.encode(bytes);
            }
            return bytes;
        },
        async decode(bytes) {
            if (!codecs)
                codecs = await load_codecs(chunk_metadata);
            for (let i = codecs.bytes_to_bytes.length - 1; i >= 0; i--) {
                bytes = await codecs.bytes_to_bytes[i].decode(bytes);
            }
            let chunk = await codecs.array_to_bytes.decode(bytes);
            for (let i = codecs.array_to_array.length - 1; i >= 0; i--) {
                chunk = await codecs.array_to_array[i].decode(chunk);
            }
            return chunk;
        },
    };
}
async function load_codecs(chunk_meta) {
    let promises = chunk_meta.codecs.map(async (meta) => {
        let Codec = await registry.get(meta.name)?.();
        assert(Codec, `Unknown codec: ${meta.name}`);
        return { Codec, meta };
    });
    let array_to_array = [];
    let array_to_bytes;
    let bytes_to_bytes = [];
    for await (let { Codec, meta } of promises) {
        let codec = Codec.fromConfig(meta.configuration, chunk_meta);
        switch (codec.kind) {
            case "array_to_array":
                array_to_array.push(codec);
                break;
            case "array_to_bytes":
                array_to_bytes = codec;
                break;
            default:
                bytes_to_bytes.push(codec);
        }
    }
    if (!array_to_bytes) {
        assert(is_typed_array_like_meta(chunk_meta), `Cannot encode ${chunk_meta.data_type} to bytes without a codec`);
        array_to_bytes = BytesCodec.fromConfig({ endian: "little" }, chunk_meta);
    }
    return { array_to_array, array_to_bytes, bytes_to_bytes };
}
function is_typed_array_like_meta(meta) {
    return meta.data_type !== "v2:object";
}
//# sourceMappingURL=codecs.js.map