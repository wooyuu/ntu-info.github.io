import { S as SLICE_TYPE, T as TypedVoxelArray } from '../nvdocument-D56hVgmz.js';
import 'gl-matrix';
import 'nifti-reader-js';

interface DrawUndoArgs {
    drawUndoBitmaps: Uint8Array[];
    currentDrawUndoBitmap: number;
    drawBitmap: Uint8Array;
}
declare const drawUndo: ({ drawUndoBitmaps, currentDrawUndoBitmap, drawBitmap }: DrawUndoArgs) => {
    drawBitmap: Uint8Array;
    currentDrawUndoBitmap: number;
} | undefined;

declare function encodeRLE(data: Uint8Array): Uint8Array;
declare function decodeRLE(rle: Uint8Array, decodedlen: number): Uint8Array;

interface DrawingDimensions {
    dimX: number;
    dimY: number;
    dimZ: number;
}
interface InterpolationOptions {
    intensityWeight?: number;
    binaryThreshold?: number;
    intensitySigma?: number;
    applySmoothingToSlices?: boolean;
    useIntensityGuided?: boolean;
    sliceType?: SLICE_TYPE;
}
/**
 * Find the first and last slices containing drawing data along a given axis
 * @param sliceType - The slice orientation (AXIAL, CORONAL, or SAGITTAL)
 * @param drawBitmap - The drawing bitmap data
 * @param dims - The volume dimensions
 * @returns Object containing first and last slice indices, or null if no data found
 */
declare function findBoundarySlices(sliceType: SLICE_TYPE, drawBitmap: Uint8Array, dims: DrawingDimensions): {
    first: number;
    last: number;
} | null;
/**
 * Extract a single slice from 3D volume data
 * @param sliceIndex - Index of the slice to extract
 * @param sliceType - The slice orientation (AXIAL, CORONAL, or SAGITTAL)
 * @param drawBitmap - The drawing bitmap data
 * @param dims - The volume dimensions
 * @returns Float32Array containing the slice data
 */
declare function extractSlice(sliceIndex: number, sliceType: SLICE_TYPE, drawBitmap: Uint8Array, dims: DrawingDimensions): Float32Array;
/**
 * Extract intensity slice from image data
 * @param sliceIndex - Index of the slice to extract
 * @param sliceType - The slice orientation
 * @param imageData - The image intensity data
 * @param dims - The volume dimensions
 * @param maxVal - Maximum value for normalization
 * @returns Float32Array containing normalized intensity values
 */
declare function extractIntensitySlice(sliceIndex: number, sliceType: SLICE_TYPE, imageData: TypedVoxelArray, dims: DrawingDimensions, maxVal: number): Float32Array;
/**
 * Insert a color mask into the drawing bitmap at a specific slice
 * @param mask - The mask data to insert
 * @param sliceIndex - Index of the slice
 * @param sliceType - The slice orientation
 * @param drawBitmap - The drawing bitmap to modify
 * @param dims - The volume dimensions
 * @param binaryThreshold - Threshold for binary conversion
 * @param color - Color value to use
 */
declare function insertColorMask(mask: TypedVoxelArray, sliceIndex: number, sliceType: SLICE_TYPE, drawBitmap: Uint8Array, dims: DrawingDimensions, binaryThreshold: number, color: number): void;
/**
 * Smooth a 2D slice using a simple 3x3 kernel
 * @param slice - The slice data to smooth
 * @param width - Width of the slice
 * @param height - Height of the slice
 */
declare function smoothSlice(slice: Float32Array, width: number, height: number): void;
/**
 * Calculate intensity-based weight for interpolation
 * @param intensity1 - Intensity from first slice
 * @param intensity2 - Intensity from second slice
 * @param targetIntensity - Target intensity to compare against
 * @param intensitySigma - Sigma parameter for weight calculation
 * @returns Weight value between 0 and 1
 */
declare function calculateIntensityWeight(intensity1: number, intensity2: number, targetIntensity: number, intensitySigma: number): number;
/**
 * Perform geometric interpolation between two slices
 * @param sliceLow - Lower slice data
 * @param sliceHigh - Higher slice data
 * @param z - Current slice index
 * @param sliceIndexLow - Lower slice index
 * @param sliceIndexHigh - Higher slice index
 * @param interpolatedSlice - Output array for interpolated values
 */
declare function doGeometricInterpolation(sliceLow: Float32Array, sliceHigh: Float32Array, z: number, sliceIndexLow: number, sliceIndexHigh: number, interpolatedSlice: Float32Array): void;
/**
 * Perform intensity-guided interpolation between two slices
 * @param sliceLow - Lower slice data
 * @param sliceHigh - Higher slice data
 * @param z - Current slice index
 * @param sliceIndexLow - Lower slice index
 * @param sliceIndexHigh - Higher slice index
 * @param interpolatedSlice - Output array for interpolated values
 * @param opts - Interpolation options
 * @param intensityLow - Intensity data for lower slice
 * @param intensityHigh - Intensity data for higher slice
 * @param targetIntensity - Target intensity data
 */
declare function doIntensityGuidedInterpolation(sliceLow: Float32Array, sliceHigh: Float32Array, z: number, sliceIndexLow: number, sliceIndexHigh: number, interpolatedSlice: Float32Array, opts: {
    intensityWeight: number;
    intensitySigma: number;
}, intensityLow: Float32Array, intensityHigh: Float32Array, targetIntensity: Float32Array): void;
/**
 * Main interpolation function for mask slices
 * @param drawBitmap - The drawing bitmap to modify
 * @param dims - The volume dimensions
 * @param imageData - Optional image intensity data for guided interpolation
 * @param maxVal - Maximum value for intensity normalization
 * @param sliceIndexLow - Lower slice index (optional)
 * @param sliceIndexHigh - Higher slice index (optional)
 * @param options - Interpolation options
 * @param refreshDrawingCallback - Callback to refresh the drawing
 */
declare function interpolateMaskSlices(drawBitmap: Uint8Array, dims: DrawingDimensions, imageData: TypedVoxelArray, maxVal: number, sliceIndexLow: number | undefined, sliceIndexHigh: number | undefined, options: InterpolationOptions, refreshDrawingCallback: () => void): void;

export { calculateIntensityWeight, decodeRLE, doGeometricInterpolation, doIntensityGuidedInterpolation, drawUndo, encodeRLE, extractIntensitySlice, extractSlice, findBoundarySlices, insertColorMask, interpolateMaskSlices, smoothSlice };
